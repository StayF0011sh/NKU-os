## 3.主要完成的功能

可以看到，在加电到完成第一条指令的过程中，总共有三个阶段

### 第一阶段：硬件复位初始化 (0x1000)
在RISC-V框架中，0x1000被定义为标准的复位向量地址；在硬件层面来看，CPU加电或复位时，程序计数器(PC)会自动跳转到0x1000。在这个过程中，CPU核心的状态会进行初始化，包括但不限于清除所有状态寄存器和禁用所有中断。而除了CPU之外，关键的硬件组件也会进行初始化，比如中断控制器、定时器和内存管理单元等。此外，执行环境建立也发生在这个阶段，比如设置临时的栈指针，配置初始异常向量表等......

总之，这个阶段是加电后的准备阶段，目的是为了保证操作系统的正常运行与工作。

### 第二阶段：SBI固件主初始化
SBI固件主初始化是RISC-V启动过程中承上启下的关键阶段，其主要目的是在硬件基础初始化完成后，为操作系统内核的加载和执行建立完整的运行环境。其具体的行为包括如下几点：

1.建立抽象硬件层。SBI在内置的代码中提供了标准的硬件访问接口，这为不同的硬件平台提供了统一的接口，让内核无需关注底层硬件的差异。
```
// SBI提供标准化的硬件访问接口
struct sbi_platform {
    uint64_t opensbi_version;
    uint64_t platform_version;
    const char *name;
    // 硬件操作函数指针
    int (*console_putc)(char ch);
    int (*console_getc)(void);
    // 更多硬件抽象接口...
};
```
2.内存系统完整初始化。这其中又包含了时序参数设置、内存映射建立和内存检测等。形象的说，这个阶段相当于对一整个连续的内存做了基本的规划与安排。
```
0x00000000 - 0x0000FFFF: 固件代码区
0x80000000 - 0x801FFFFF: 设备映射区
0x80200000 - 0x803FFFFF: 内核加载区  
0x80400000 - 0x8FFFFFFF: 内核运行堆区
0x90000000 - 0x9FFFFFFF: 设备树和启动参数
```
(内存布局规划参考)
3.内核加载和验证。这个阶段主要是为了保护操作系统的安全，通过数字签名和HASH校验来确保内核未被篡改，也确保了内核与硬件平台的兼容。

### 第三阶段：控制权移交内核(0x80200000)
第三阶段的核心事件，就是将中央处理器的执行流，从SBI固件手中，正式移交给操作系统内核。

首先，CPU的程序计数器被设置到 0x80200000，这是RISC-V架构中约定俗成的内核入口地址。执行的第一条指令 ```aulpc sp, 0x3``` 立刻展现出了内核与固件的分离：它为内核建立了一个专属的、独立的栈空间。这个动作意义重大，因为栈是函数调用、局部变量等C代码运行的基础。内核绝不能与固件共享栈空间，否则会造成灾难性的数据混乱。

紧接着，执行流程通过一条跳转指令 ```j kern_init```进入了用C语言编写的内核主初始化函数。这条指令的执行象征了控制权的移交。从此，CPU将不再执行固件的代码，而是完全听从内核的调度。

内核在 ```kern_init``` 中，目的非常明确：从零开始，构建一个完整、自持的操作系统管理架构。不论是硬件的管理、识别与适配还是异常状态的检测与校正，自此都被装在了这个操作系统的框架中，而在这背后的是内存权限的升级——从固件运行的机器模式切换到操作系统本该拥有的监督模式。这将启用虚拟内存等强大的保护机制，确保用户程序无法直接访问硬件，从而奠定了系统安全和稳定的基石。

### 实验中的重要知识点
1.linux系统的相关配置和使用。
2.GDB和Qemu配合使用完成对操作系统代码的调试，在调试中可以观察到每个阶段操作系统的行为，有利于更好的理解现代操作系统的准备过程，加深了对操作系统的认识
3.在深入研究理解每个阶段的目的与内容后，我认为课上学习的有关分页和内存管理的内容应该发生在第二阶段，对内存的划分使得操作系统在使用时更加的流畅和安全。

### 很重要但没实验提及的知识点
我认为本实验没有涉及到很多细节方面的内容，比如对于内存管理中的很多针对于解决异常情况的算法，在实验中没有办法看到他们的运行原理。而且对于更多的操作系统在运行时的状态和改变，本实验也没有涉及。